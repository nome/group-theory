module GroupTheory where
import Data.List

{-
 - Some basic group theoretical functions.
 -
 - The intention here is to exploit Haskell's nice syntax and type system in order to provide
 - a clear, readable description of the concepts involved. The fact that you can actually run
 - this description on a computer and explore what it does is more or less a bonus. Particularly,
 - little to no effort has been invested in making the code efficient.
 -
 - Usage example: The dihedral group of order 8.
 -
 - module Main where
 - import GroupTheory
 -
 - data Vertex = A | B | C | D deriving (Eq, Enum, Bounded, Show)
 - d4 = [(cycle4 A B C D), (cycle2 A C)]
 - main = do
 - 	print $ generatedGroup d4
 - 	print $ conjugacyClasses d4
 - 	print $ subgroups d4
 -
 - Alternatively, you can use the presentation <b,c | c^4=b^2=(bc)^2=e> for D_4:
 -
 - data Generator = B | C deriving (Eq, Ord, Enum, Bounded, Show)
 - instance Presentation Generator where
 -    relators = [ power (gen C) 4, power (gen B) 2, power (gen C ° gen B) 2 ]
 - d4 = map subjugate [ gen B, gen C ]
 -}

{------------------------------------------------------------------------------
 - some utility functions not specific to group theory
 ------------------------------------------------------------------------------}
 
{-
 - Moderately similar to iterate, but allows the function to generate multiple elements in one go
 - and also takes multiple start values. Returns a list of all values that can be generated by
 - repeated application of f to elements of the input list. In contrast to iterate, setIterate
 - terminates when f does not produce any new values.
 -}
setIterate :: Eq a => (a -> [a]) -> [a] -> [a]
setIterate f list = iter list list
	where
		iter accum [] = accum
		iter accum todo = iter (newElements ++ accum) newElements where
			generatedElements = foldl (\a x -> (union a) $ f x) [] todo
			newElements = generatedElements \\ accum

{-
 - What the name says - swap the (first two) arguments of a function.
 -}
swapArgs :: (a -> b -> c) -> (b -> a -> c)
swapArgs f x y = f y x

{-
 - Test two lists for equality, assuming they represent sets (i.e. test whether they contain the
 - same set of elements, in any order).
 -}
setEqual :: Eq a => [a] -> [a] -> Bool
setEqual l1 l2 = (length l1) == (length l2) && null (nub l1 \\ l2)

{-
 - Determine maximal suffix of the left list (x) that is equal to a prefix of the right list (y),
 - i.e. the overlap between the lists. Return a triple (a,b,c) consisting of the left list without
 - the common part, the common part, and the right list without the common part; such that
 - x == a++b and y == b++c hold.
 -}
overlapSplit :: Eq a => [a] -> [a] -> ([a],[a],[a])
overlapSplit [] l2 = ([], [], l2)
overlapSplit l1@(l:ls) l2 = case stripPrefix l1 l2 of
	Just rest -> ([], l1, rest)
	Nothing -> let (a,b,c) = overlapSplit ls l2 in (l:a,b,c)

{------------------------------------------------------------------------------
 - basic group theory definitions and functions
 ------------------------------------------------------------------------------}

{-
 - Of course, the point here is that instances of this class have to obey the group axioms;
 - i.e. ° has to be associative, g°neutral==g and g°(inverse g)==neutral for all possible values.
 - Otherwise, using the instance will likely yield unexpected results.
 -}
class Group a where
	(°) :: a -> a -> a
	neutral :: a
	inverse :: a -> a

{-
 - Raise a group element to an integer power (using the group axioms).
 -}
power :: Group a => a -> Int -> a
power g n
	| n > 0  = (iterate (g°) g) !! (n-1)
	| n == 0 = neutral
	| n < 0  = power (inverse g) (-n)

{-
 - Conjugate of p with respect to q.
 -}
conjugate :: Group a => a -> a -> a
conjugate q p = q ° p ° inverse q

{-
 - Commutator of p and q
 -}
commutator :: Group a => a -> a -> a
commutator p q = p ° q ° inverse (q ° p)

{------------------------------------------------------------------------------
 - finitely generated groups
 - (actually, most of the functions here assume that the group itself is finite)
 ------------------------------------------------------------------------------}

{-
 - Compute a list of all distinct elements that can be built from the generators, which form a
 - group (given that type "a" satisfies the group axioms).
 -}
generatedGroup :: (Group a, Eq a) => [a] -> [a]
generatedGroup generators = union [neutral] $ setIterate (\h -> map (h°) base) base
	where
		base = union generators (map inverse generators)

{-
 - Given a generated group and an element thereof, return a list of all elements conjugated to it;
 - i.e. its conjugacy class.
 -}
conjugacyClass :: (Group a, Eq a) => [a] -> a -> [a]
conjugacyClass generators g = setIterate (\h -> map (swapArgs conjugate h) base) [g]
	where
		base = union generators (map inverse generators)

{-
 - Compute all conjugacy classes of the given generated group.
 -}
conjugacyClasses :: (Group a, Eq a) => [a] -> [[a]]
conjugacyClasses generators = classify (generatedGroup generators) where
	classify [] = []
	classify (x:xs) = let c = conjugacyClass generators x in c:(classify (xs \\ c))

{-
 - Compute all subgroups of the given generated group.
 - This can be pretty time consuming even for small groups.
 -}
subgroups :: (Group a, Eq a) => [a] -> [[a]]
subgroups generators = nubBy setEqual [ generatedGroup (concat minSubGroups) | minSubGroups <- subsequences minimalSubgroups ]
	where
		minimalSubgroups = nubBy setEqual [ generatedGroup [g] | g <- generatedGroup generators ]

{-------------------------------------------------------------
 - permutation groups - symmetric groups and their subgroups
 -------------------------------------------------------------}

{-
 - We use association lists for representing permutations, because that's the conceptually simplest
 - way (i.e. should be understandable with very basic knowledge of Haskell). The slightly clumsy
 - lookup syntax is worked around by adding a function "permute" to do this.
 -}
newtype Permutation a = Permutation [(a,a)]

{-
 - Applying a permutation to the underlying set just means looking up the elements in the
 - association list. It is generally assumed that the association list is complete, i.e. contains
 - all possible values of the underlying type; but since we formally need some return value in case
 - of lookup failure, we'll just leave elements without association invariant.
 -}
permute :: Eq a => Permutation a -> a -> a
permute (Permutation p) x = case lookup x p of
	Just y -> y
	Nothing -> x

{-
 - Two permutations are equal iff they have the same set of associations. This one does depend on
 - the association lists being complete (else different association lists describing the same
 - permutation may compare unequal).
 -}
instance Eq a => Eq (Permutation a) where
	(Permutation p1) == (Permutation p2) = setEqual p1 p2

{-
 - The symmetric group of a bounded, enumerable type (=> finite set).
 - While the list of values to operate on is implicit in the representation chosen for permutations,
 - we need explicit bounds and enumerability in order to construct the neutral element.
 -}
instance (Eq a, Enum a, Bounded a) => Group (Permutation a) where
	p1 ° p2 = Permutation $ [(x, permute p1 $ permute p2 x) | x <- enumFromTo minBound maxBound]
	neutral = Permutation $ [(x,x) | x <- enumFromTo minBound maxBound]
	inverse (Permutation p) = Permutation $ map (\(a,b) -> (b,a)) p

{-
 - Define an ordering of permutations based on their verbose representation
 - / 1    2    ... n    \
 - \ p(1) p(2) ... p(n) /
 -}
instance (Eq a, Ord a, Enum a, Bounded a) => Ord (Permutation a) where
	compare p1 p2 = compare [permute p1 x | x <- enumFromTo minBound maxBound] [permute p2 x | x <- enumFromTo minBound maxBound]

{-
 - Orbit of x under the cyclic group generated by f.
 - f is assumed to describe the action of an element of a finite group on type a; otherwise, the
 - result may be an infinite list (and technically the term "orbit" isn't usually defined for
 - arbitrary f).
 -}
orbit :: Eq a => (a -> a) -> a -> [a]
orbit f x = x : (takeWhile (/= x) $ iterate f (f x))

{-
 - Disjoint cycle decomposition of permutations.
 -}
cycles :: (Eq a, Enum a, Bounded a) => Permutation a -> [[a]]
cycles p = cyclesContaining (enumFromTo minBound maxBound)
	where
		cyclesContaining [] = []
		cyclesContaining (x:xs) = let o = orbit (permute p) x in o:(cyclesContaining (xs\\o))

{-
 - Use cyclic notation for displaying permutations (omitting 1-cycles).
 -}
instance (Eq a, Enum a, Bounded a, Show a) => Show (Permutation a) where
	show p | null nontrivialCycles = "()"
	       | otherwise = concat $ map (("("++) . (++")") . showCycle) nontrivialCycles
		where
			nontrivialCycles = filter ((>1).length) $ cycles p
			showCycle (x:[]) = show x
			showCycle (x:rest) = show x ++ " " ++ showCycle rest

{-
 - Make permutation from a bijection on the underlying set.
 -}
permutationFromBijection :: (Enum a, Bounded a) => (a -> a) -> Permutation a
permutationFromBijection f = Permutation [(x, f x) | x <- enumFromTo minBound maxBound]

{-
 - Make permutation from a two cycle (convenience function).
 -}
cycle2 :: (Eq a, Enum a, Bounded a) => a -> a -> Permutation a
cycle2 a b = permutationFromBijection act
	where act i	| i == a = b
				| i == b = a
				| otherwise = i

{-
 - Make permutation from a three cycle (convenience function).
 -}
cycle3 :: (Eq a, Enum a, Bounded a) => a -> a -> a -> Permutation a
cycle3 a b c = permutationFromBijection act
	where act i	| i == a = b
				| i == b = c
				| i == c = a
				| otherwise = i

{-
 - Make permutation from a four cycle (convenience function).
 -}
cycle4 :: (Eq a, Enum a, Bounded a) => a -> a -> a -> a -> Permutation a
cycle4 a b c d = permutationFromBijection act
	where act i	| i == a = b
				| i == b = c
				| i == c = d
				| i == d = a
				| otherwise = i

{-
 - Make permutation from a five cycle (convenience function).
 -}
cycle5 :: (Eq a, Enum a, Bounded a) => a -> a -> a -> a -> a -> Permutation a
cycle5 a b c d e = permutationFromBijection act
	where act i	| i == a = b
				| i == b = c
				| i == c = d
				| i == d = e
				| i == e = a
				| otherwise = i

{-------------------------------------------------------------
 - finitely presented groups
 -------------------------------------------------------------}
 
{-
 - Elements of a free group are words in the generators and their inverses, modelled as a list of
 - Left x (representing generator x) and Right x (representing x^-1) values.
 -}
data Word a = Word [Either a a] deriving Eq

{-
 - The free group generated by values of some type "a".
 -}
instance Group (Word a) where
	(Word w) ° (Word w') = Word (w ++ w')
	neutral = Word []
	inverse (Word w) = Word $ reverse $ map invert w where
		invert (Left x) = (Right x)
		invert (Right x) = (Left x)

{-
 - Canonical embedding of a type into the free group over its values.
 -}
gen :: a -> Word a
gen x = Word [Left x]

{-
 - Shortlex order: Words are ordered by length first, then by whatever ordering is defined on the
 - underlying type.
 -}
instance Ord a => Ord (Word a) where
	compare (Word w1) (Word w2) = case compare (length w1) (length w2) of
		LT -> LT
		GT -> GT
		EQ -> compare w1 w2

{-
 - Use a compact display format optimized for generator data types with a one-letter display format.
 -}
instance Show a => Show (Word a) where
	show (Word w) = if null w then "e" else concatMap showLetter w
		where showLetter l = case l of
			Left x -> show x
			Right x -> show x ++ "'"

{-
 - Shorthand for an association list mapping words to words, interpreted as substitution rules.
 -}
type RewriteRules a = [(Word a, Word a)]

{-
 - Apply a set of rewrite rules to a word until none of them matches any more.
 -}
applyRewriteRules :: Eq a => RewriteRules a -> Word a -> Word a
applyRewriteRules allRules word = iter allRules word
	where
		-- recursively apply the rules on successive modifications of the input word
		iter _ (Word []) = Word []
		iter [] word = word
		iter rules@(r:rs) word = case tryRewrite r word of
			Just word' -> iter allRules word' -- try all rules again on changed word
			Nothing -> iter rs word -- try rest of rules on unchanged word

		-- try to apply one rule to its first occurance, if any, in the input word
		tryRewrite :: Eq a => (Word a, Word a) -> Word a -> Maybe (Word a)
		tryRewrite _ (Word []) = Nothing
		tryRewrite rule@(Word left, Word right) (Word input@(i:is)) = case stripPrefix left input of
			Just rest -> return $ Word $ right ++ rest
			Nothing -> do
				Word result <- tryRewrite rule (Word is)
				return $ Word (i:result)

{-
 - Use Knuth-Bendix algorithm to extend the rewrite rules given by relators and the inverses to a
 - confluent term rewriting system. This is not guaranteed to succeed (read: terminate in finite
 - time) for any set of relators; in fact, it can be proven that there are groups with undecidable
 - word problem; i.e., there's also no other algorithm which does the same task for every possible
 - input.
 -
 - References:
 - http://en.wikipedia.org/wiki/Knuth–Bendix_completion_algorithm
 - GAP, http://www.gap-system.org, file kbsemi.gi
 -}
knuthBendixCompletion :: (Eq a, Ord a) => [a] -> [Word a] -> RewriteRules a
knuthBendixCompletion generators relators = extend baseRules
	where
		-- starting point: inverse relations and specified relators, which are first of all
		-- subjected to an initial reduction step
		baseRules = reduce (rightInverseRules ++ leftInverseRules ++ relatorRules)
		reduce rules = if selfApply == rules then rules else reduce selfApply
			where selfApply = do
				rule@(left,Word[]) <- rules
				let left'@(Word wl) = applyRewriteRules (delete rule rules) left
				if null wl then fail "discard redundant rule" else return (left', Word[])
		rightInverseRules = map (\x -> (Word [Left x, Right x], Word [])) generators
		leftInverseRules = map (\x -> (Word [Right x, Left x], Word [])) generators
		relatorRules = map (\r -> (r, Word [])) relators
		
		-- find exceptions of confluence, i.e. terms that yield different results when reduced with
		-- different rules
		findConfluenceExceptions rules = do
			(Word p, Word q) <- rules
			(Word p', Word q') <- rules
			let (left, overlap, right) = overlapSplit p p'
			-- applying p->q first, we get:
			let r = applyRewriteRules rules $ Word (q++right)
			-- applying p'->q' first, we get:
			let r' = applyRewriteRules rules $ Word (left++q')
			-- supposing results differ, this new rule fixes the confluence exception:
			let newRule = (max r r', min r r')
			if p == p'|| null overlap || r == r' then fail "no confluence exception for p,p'" else return newRule
		
		extend rules = case findConfluenceExceptions rules of
			[] -> rules -- we already have a confluent rewriting system
			-- Note that we only ever use the first exception found, since adding the new rule may
			-- invalidate old ones and thus also the other confluence exceptions. There may be more
			-- efficient ways to deal with this, but keep in mind that the list of exceptions is
			-- computed lazily; and that efficiency isn't a primary design goal.
			(newRule@(left,right):_) -> case lookup left rules of
				-- If there are two ways to rewrite the same word, choose the one with the smaller
				-- result (no other rules need changing, since they could have been rewritten using
				-- the original rule). Iteratively search for more exceptions of confluence.
				Just right' -> extend $ (left, min right right'):(delete (left,right') rules)
				-- Otherwise, add the new rule, apply the extended rewriting system to the rules
				-- themselves and drop rules which have gotten redundant. Iteratively search for
				-- more exceptions of confluence.
				Nothing -> extend $ newRule:do
					rule@(left,right) <- rules
					let left' = applyRewriteRules (newRule:(delete rule rules)) left
					let right' = applyRewriteRules (newRule:rules) right
					if left' <= right' then [] else return (left',right')

{-
 - A presentation is a set of generators together with a set of relators. The generators are
 - implicitly given as the possible values of a bounded enumerable type.
 -}
class (Eq a, Ord a, Enum a, Bounded a) => Presentation a where
	relators :: [Word a]

{-
 - An element of the group specified by a presentation, represented by a word in the generators.
 - The difference to Word is that words are identified according to the equivalence relation
 - induced by the relators. An other way to put this is that a value of "PresentationCoset a"
 - represents a coset of the normal closure of the presentation's relators in the free group
 - generated by the presentation's generators (hence the name).
 -
 - Note that in a small nod towards a halfway usable runtime efficiency, and in order to prevent
 - the internal representation from becoming excessively large after some applications of the group
 - operation, words are rewritten to canonical form whenever a presentation coset is created and not
 - whenever it's compared, shown or otherwise used. This means that using the PresentationCoset
 - constructor directly should be avoided, since using it on a non-canonicalized word can invalidate
 - results of subsequent calculations. Use "subjugate" instead.
 -}
data PresentationCoset a = PresentationCoset [Either a a] deriving Eq

{-
 - Canonical map from the free group to the quotient group defined by a presentation.
 - Using the Knuth-Bendix completion algorithm (knuthBendixCompletion), translation rules are
 - generated from the relations of the presentation and then applied to a given word in order
 - to bring it into a canonical form.
 -}
subjugate :: Presentation a => Word a -> PresentationCoset a
subjugate w = PresentationCoset canonical
	where Word canonical = applyRewriteRules canonicalizationRules w

{-
 - Currently only used as a utility variable for subjugate; but when including this in a where clause,
 - GHC fails to notice that it needs to be computed only once per presentation.
 -}
canonicalizationRules :: Presentation a => RewriteRules a
canonicalizationRules = knuthBendixCompletion (enumFromTo minBound maxBound) relators

{-
 - If type "a" is a presentation, then the words in the values of "a" form a group generated by the
 - possible values of "a". The group mapping is given by concatenation of words modulo reduction.
 -}
instance Presentation a => Group (PresentationCoset a) where
	(PresentationCoset w) ° (PresentationCoset w') = subjugate (Word (w ++ w'))
	neutral = PresentationCoset []
	inverse (PresentationCoset w) = subjugate $ Word $ reverse $ map invert w where
		invert (Left x) = (Right x)
		invert (Right x) = (Left x)

{-
 - In a slight abuse of notation, display cosets as plain words (as usual). If you want to be
 - pedantic, you'd have to write something like "abaN" or "[aba]" to denote the coset represented
 - by the word "aba".
 -}
instance Show a => Show (PresentationCoset a) where
	show (PresentationCoset w) = show (Word w)

{-
 - Use the same ordering for cosets as for their canonical representatives.
 -}
instance (Eq a, Ord a) => Ord (PresentationCoset a) where
	compare (PresentationCoset w) (PresentationCoset w') = compare (Word w) (Word w')

-- http://en.wikipedia.org/wiki/Todd–Coxeter_algorithm
