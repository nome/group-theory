module GroupTheory where
import Data.Array
import Data.List

{-
 - Some (very) basic group theoretical functions.
 -
 - The intention here is to exploit Haskell's nice syntax and type system in order to provide
 - a clear, readable description of the concepts involved. The fact that you can actually run
 - this description on a computer and explore what it does is more or less a bonus. Particularly,
 - little to no effort has been invested in making the code efficient.
 -
 - Usage example: The dihedral group of order 8.
 -
 - module Main where
 - import GroupTheory
 - import Array
 -
 - data Vertex = A | B | C | D deriving (Eq, Ord, Ix, Bounded, Show)
 - d4 = GeneratedGroup [(cycle4 A B C D), (cycle2 A B) ° (cycle2 C D)]
 - main = do
 - 	print $ elements d4
 - 	print $ conjugacyClasses d4
 - 	print $ subgroups d4
 -}

{------------------------------------------------------------------------------
 - some utility functions not specific to group theory
 ------------------------------------------------------------------------------}
 
 stabilize :: Eq a => (a -> a) -> a -> a
 stabilize f x = if next == x then x else stabilize f next
 	where
		next = f x

{-
 - Moderately similar to iterate, but allows the function to generate multiple elements in one go
 - and also takes multiple start values. Returns a list of all values that can be generated by
 - repeated application of f to elements of the input list.
 -}
setIterate :: Eq a => (a -> [a]) -> [a] -> [a]
setIterate f list = iter list list
	where
		iter accum [] = accum
		iter accum todo = iter (newElements ++ accum) newElements where
			generatedElements = foldl (\a x -> (union a) $ f x) [] todo
			newElements = generatedElements \\ accum

{-
 - What the name says - swap the (first two) arguments of a function.
 -}
swapArgs :: (a -> b -> c) -> (b -> a -> c)
swapArgs f x y = f y x

{------------------------------------------------------------------------------
 - basic group theory definitions and functions
 ------------------------------------------------------------------------------}

{-
 - Of course, the point here is that instances of this class have to obey the group axioms;
 - i.e. ° has to be associative, g°neutral==g and g°(inverse g)==neutral for all possible values.
 - Otherwise, using the instance will likely yield unexpected results.
 -}
class Group a where
	(°) :: a -> a -> a
	neutral :: a
	inverse :: a -> a

{-
 - Raise a group element to an integer power (using the group axioms).
 -}
power :: Group a => a -> Int -> a
power g n
	| n > 0  = (iterate (g°) g) !! (n-1)
	| n == 0 = neutral
	| n < 0  = power (inverse g) (-n)

{-
 - Conjugate of p with respect to q.
 -}
conjugate :: Group a => a -> a -> a
conjugate q p = q ° p ° inverse q

{-
 - Commutator of p and q
 -}
commutator :: Group a => a -> a -> a
commutator p q = p ° q ° inverse (q ° p)

{------------------------------------------------------------------------------
 - finitely generated groups
 - (actually, most of the functions here assume that the group itself is finite)
 ------------------------------------------------------------------------------}

{-
 - Basically, a generated group is defined by a list of generators, which are required to be of a
 - type of class Group.
 -}
data (Group a, Eq a) => GeneratedGroup a = GeneratedGroup [a]

{-
 - Unpack list of generators from GeneratedGroup constructor.
 -}
generators :: (Group a, Eq a) => GeneratedGroup a -> [a]
generators (GeneratedGroup gens) = gens

{-
 - Compute a list of all distinct elements that can be built from the generators, i.e. the set of
 - the group's elements.
 -}
elements :: (Group a, Eq a) => GeneratedGroup a -> [a]
elements group = union [neutral] $ setIterate (\h -> map (h°) base) base
	where
		base = union (generators group) (map inverse (generators group))

{-
 - Given a generated group and an element thereof, return a list of all elements conjugated to it;
 - i.e. its conjugacy class.
 -}
conjugacyClass :: (Group a, Eq a) => GeneratedGroup a -> a -> [a]
conjugacyClass group g = setIterate (\h -> map (swapArgs conjugate h) base) [g]
	where
		base = union (generators group) (map inverse (generators group))

{-
 - Compute all conjugacy classes of the given generated group.
 -}
conjugacyClasses :: (Group a, Eq a) => GeneratedGroup a -> [[a]]
conjugacyClasses group = classify (elements group) where
	classify [] = []
	classify (x:xs) = let c = conjugacyClass group x in c:(classify (xs \\ c))

{-
 - Compute all subgroups of the given generated group.
 -}
subgroups :: (Group a, Eq a) => GeneratedGroup a -> [[a]]
subgroups group = nubBy setEqual [ elements $ GeneratedGroup (concat minSubGroups) | minSubGroups <- subsequences minimalSubgroups ]
	where
		minimalSubgroups = nubBy setEqual [ elements $ GeneratedGroup [g] | g <- elements group ]
		setEqual a b = (length a) == (length b) && null (a \\ b)

{-------------------------------------------------------------
 - permutation groups - symmetric groups and their subgroups
 -------------------------------------------------------------}

{-
 - We use arrays for representing permutations, because they have O(1) random access; and because
 - they've got quite nice access syntax.
 - However, this means that the underlying set to be permuted must be a type of class Ix.
 -}
newtype Permutation a = Permutation (Array a a) deriving Eq

{-
 - Unpack the internal representation of a permutation.
 -}
permutationArray :: Ix a => Permutation a -> Array a a
permutationArray (Permutation p) = p

{-
 - Applying a permutation to the underlying set just means looking up the elements in the array.
 -}
permute :: Ix a => Permutation a -> a -> a
permute (Permutation p) x = p ! x

{-
 - The symmetric group of a type of class Bounded.
 - While bounds are implicit in the representation chosen for permutations, they must be made
 - explicit in order to construct the neutral element.
 -}
instance (Ix a, Bounded a) => Group (Permutation a) where
	p1 ° p2 = Permutation $ listArray pRange $ map (permute p1 . permute p2) (range pRange)
		where pRange = (minBound,maxBound)
	neutral = Permutation $ listArray pRange (range pRange)
		where pRange = (minBound,maxBound)
	inverse (Permutation p) = Permutation $ array (bounds p) $ map swap (assocs p)
		where swap (a,b) = (b,a)

{-
 - Orbit of x under the cyclic group generated by f.
 - f is assumed to describe the action of an element of a finite group on type a; otherwise, the
 - result may be an infinite list (and technically the term "orbit" isn't usually defined for
 - arbitrary f).
 -}
orbit :: Eq a => (a -> a) -> a -> [a]
orbit f x = x : (takeWhile (/= x) $ iterate f (f x))

{-
 - Disjoint cycle decomposition of permutations.
 -}
cycles :: Ix a => Permutation a -> [[a]]
cycles p = cyclesContaining . range . bounds . permutationArray $ p
	where
		cyclesContaining [] = []
		cyclesContaining (x:xs) = let o = orbit (permute p) x in o:(cyclesContaining (xs\\o))

{-
 - Use cyclic notation for displaying permutations (omitting 1-cycles).
 -}
instance (Ix a, Show a) => Show (Permutation a) where
	show p | null nontrivialCycles = "()"
	       | otherwise = concat $ map (("("++) . (++")") . showCycle) nontrivialCycles
		where
			nontrivialCycles = filter ((>1).length) $ cycles p
			showCycle (x:[]) = show x
			showCycle (x:rest) = show x ++ " " ++ showCycle rest

{-
 - Make permutation from a bijection on the underlying set.
 -}
permutationFromAction :: (Ix a, Bounded a) => (a -> a) -> Permutation a
permutationFromAction f = Permutation $ array (minBound,maxBound) [(i, f i) | i <- range(minBound,maxBound)]

{-
 - Make permutation from a two cycle (convenience function).
 -}
cycle2 :: (Ix a, Bounded a) => a -> a -> Permutation a
cycle2 a b = permutationFromAction act
	where act i | i == a = b
	            | i == b = a
					| otherwise = i

{-
 - Make permutation from a three cycle (convenience function).
 -}
cycle3 :: (Ix a, Bounded a) => a -> a -> a -> Permutation a
cycle3 a b c = permutationFromAction act
	where act i | i == a = b
			      | i == b = c
			      | i == c = a
			      | otherwise = i

{-
 - Make permutation from a four cycle (convenience function).
 -}
cycle4 :: (Ix a, Bounded a) => a -> a -> a -> a -> Permutation a
cycle4 a b c d = permutationFromAction act
	where act i | i == a = b
			      | i == b = c
			      | i == c = d
			      | i == d = a
			      | otherwise = i

{-
 - Make permutation from a five cycle (convenience function).
 -}
cycle5 :: (Ix a, Bounded a) => a -> a -> a -> a -> a -> Permutation a
cycle5 a b c d e = permutationFromAction act
	where act i | i == a = b
			      | i == b = c
			      | i == c = d
			      | i == d = e
					| i == e = a
			      | otherwise = i

{-------------------------------------------------------------
 - finitely presented groups - as subgroups of a free group
 -------------------------------------------------------------}

-- Words in the generators are modelled as a list of Left x (=x) and Right x (=x^-1) values.
data PresentedGroupElement a = PresentedGroupElement [Either a a]

-- The group data structure consists of a list of generators and a list of relators.
data PresentedGroup a = PresentedGroup [a] [PresentedGroupElement a]

type RewriteRules a = [(PresentedGroupElement a, PresentedGroupElement a)]

applyRewriteRules :: Eq a => RewriteRules a -> PresentedGroupElement a -> PresentedGroupElement a
applyRewriteRules rules (PresentedGroupElement word) = PresentedGroupElement $ iter rules word
	where
		iter [] w = w
		iter (r:rs) [] = 
		iter ((PresentedGroupElement rl, PresentedGroupElement rr):rs) w@(l:ls) = if rl `isPrefixOf` w then iter rules $ rr ++ (drop (length rl) word) else l:(iter rules ls)

-- Knuth-Bendix algorithm for producing a confluent term rewriting system from the given relations.
-- Does not terminate for certain groups; particularly those with undecidable word problem.
-- Which is to say that it can be proven that there's no algorithm which succeeds for all possible
-- inputs.
knuthBendixRewrite :: Eq a => PresentedGroup a -> [(PresentedGroupElement a, PresentedGroupElement a)]
knuthBendixRewrite (PresentedGroup generators relators) = step $ inverseRules ++ relatorRules
	where
		inverseRules = map (\x -> (PresentedGroupElement [Left x, Right x], PresentedGroupElement [])) generators
		relatorRules = map (\r -> (r, PresentedGroupElement [])) relators
		reduce rules = 

-- http://en.wikipedia.org/wiki/Knuth–Bendix_completion_algorithm  (-> GAP, kbsemi.gi)
-- http://en.wikipedia.org/wiki/Todd–Coxeter_algorithm
